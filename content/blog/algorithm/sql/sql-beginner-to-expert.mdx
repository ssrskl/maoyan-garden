---
title: SQL 从入门到精通
description: SQL 从入门到精通
date: 2025-12-18 17:32:00
tags: ["算法", "SQL"]
published: true
status: growing
---

export const SAMPLE_DATA = {
    columns: [
        { id: "primary_key", title: "主键", type: "url", width: 150 },        
        {
            id: "tags",
            title: "标签",
            type: "multi-select",
            width: 200,
            options: [
                { id: "self_join", label: "自连接", color: "#fdecc8" },
                { id: "group_by", label: "分组统计", color: "#ffe2dd" },
            ],
        },
        {
            id: "title",
            title: "SQL算法题所属",
            type: "multi-select",
            width: 350,
            options: [
                { id: "friend_recommendation", label: "好友推荐", color: "#00000" ,url: "/blog/algorithm/sql/sql-beginner-to-expert#好友推荐"},
                { id: "two_pair", label: "两两结对组", color: "#00000" ,url: "/blog/algorithm/sql/sql-beginner-to-expert#两两结对组"},
                { id: "firm_friendship", label: "坚定的友谊", color: "#00000" ,url: "/blog/algorithm/sql/sql-beginner-to-expert#坚定的友谊"},
                { id: "continuous_login", label: "连续登录", color: "#00000" ,url: "/blog/algorithm/sql/sql-beginner-to-expert#连续登录"},
                { id: "continuous_login", label: "数据连续", color: "#00000" ,url: "/blog/algorithm/sql/sql-beginner-to-expert#数据连续"},
                { id: "continuous_login", label: "连胜数", color: "#00000" ,url: "/blog/algorithm/sql/sql-beginner-to-expert#连胜数"},
            ],
        },
    ],
    rows: [
        {
            id: "1",
            cells: {
                primary_key: { text: "自连接+分组统计", url: "/blog/algorithm/sql/sql-beginner-to-expert#%E8%87%AA%E8%BF%9E%E6%8E%A5%E5%88%86%E7%BB%84%E7%BB%9F%E8%AE%A1" },
                tags: ["self_join", "group_by"],
                title: ["friend_recommendation","two_pair","firm_friendship"],
            },
        },
        {
            id: "2",
            cells: {
                primary_key: {text: "分组连续问题", url: "/blog/algorithm/sql/sql-beginner-to-expert#分组连续问题"},
                title: ["continuous_login"],
            },
        },
        {
            id: "3",
            cells: {
                title: "Update Documentation",
                status: "done",
                tags: ["documentation"],
                effort: 1,
                link: { text: "Next.js 文档", url: "https://nextjs.org" },
            },
        },
    ],
};

<DatabaseTable initialData={SAMPLE_DATA} />

# 自连接+分组统计
本质是求得至少拥有 n 个相同属性的用户有哪些，所以可以以下的方式来实现

1. 根据共同属性进行关联，找到拥有共同属性的用户
2. 进行过滤，只保留单边
3. 对拥有共同属性的两个用户进行分组，计算拥有共同属性的数量

## 好友推荐
到所有的好友推荐，好友推荐为：用户A和用户B都听了至少3首不同的歌曲，且用户A和用户B不是好友关系
```sql
with listens(user_id, song_id,day) as (
    select 1, '10', '2021-03-15' union all
    select 1, '11', '2021-03-15' union all
    select 1, '12', '2021-03-15' union all
    select 2, '10', '2021-03-15' union all
    select 2, '11', '2021-03-15' union all
    select 2, '12', '2021-03-15' union all
    select 3, '10', '2021-03-15' union all
    select 3, '11', '2021-03-15' union all
    select 3, '12', '2021-03-15' union all
    select 4, '10', '2021-03-15' union all
    select 4, '11', '2021-03-15' union all
    select 4, '13', '2021-03-15' union all
    select 5, '10', '2021-03-16' union all
    select 5, '11', '2021-03-16' union all
    select 5, '12', '2021-03-16'
)
```
```sql
friendship (user1_id, user2_id) as (
    select 1, 2
)
```
这里的共同属性是（歌曲+时间），所以同时满足这两个属性相同的数据

```sql
t1 as (
    SELECT l1.user_id as user1_id, l2.user_id as user2_id, count(*)
    FROM listens l1
        LEFT JOIN listens l2 ON l1.song_id = l2.song_id
        AND l1.day = l2.day
    WHERE
        l1.user_id < l2.user_id
    GROUP BY
        l1.user_id,
        l2.user_id
    HAVING
        count(*) >= 3
)

SELECT *
FROM t1
WHERE
    concat(user1_id, user2_id) NOT IN (
        SELECT concat(user1_id, user2_id)
        FROM friendship
    )
```

## 两两结对组
## 坚定的友谊

# 分组连续问题

针对分组连续问题，主要的核心，就是找到各组的 group id，可以分为有分割点和无分割点两种类型：

1. **数据顺序连续，一般为数据+1，或者日期+1**

   1. 求出总连续，例如 `row_number`函数
   2. 求出局部分连续，**例如连续的日期**，或者其他的
   3. 局部分连续减去总连续，或者局部分连续减去总连续，得到分组
2. **相同的数据连续，例如连续 Win5 场**

   1. 通过 `lag` ，与上一个数据进行对比，创建出 `is_change` 字段，用 0 和 1 表示
   2. 再使用 `sum` 相加 `is_change`，即可得到各个分组
## 数据顺序连续问题
### 连续登录

## 相同数据连续问题

### 数据连续
### 连胜数
找到每个选手的最大连胜数量，没有胜利的为 0
```sql
WITH Matches (player_id, match_day, result) AS (
    -- 选手1的比赛数据：3连胜（Win）+ 中断（Draw）+ 2连胜（Win）
    SELECT 1, '2025-01-01', 'Win' UNION ALL
    SELECT 1, '2025-01-02', 'Win' UNION ALL
    SELECT 1, '2025-01-03', 'Win' UNION ALL
    SELECT 1, '2025-01-04', 'Draw' UNION ALL
    SELECT 1, '2025-01-05', 'Win' UNION ALL
    SELECT 1, '2025-01-06', 'Win' UNION ALL
    -- 选手2的比赛数据：2连胜（Win）+ 中断（Lose）+ 4连胜（Win）
    SELECT 2, '2025-01-01', 'Win' UNION ALL
    SELECT 2, '2025-01-02', 'Win' UNION ALL
    SELECT 2, '2025-01-03', 'Lose' UNION ALL
    SELECT 2, '2025-01-04', 'Win' UNION ALL
    SELECT 2, '2025-01-05', 'Win' UNION ALL
    SELECT 2, '2025-01-06', 'Win' UNION ALL
    SELECT 2, '2025-01-07', 'Win' UNION ALL
    -- 选手3的比赛数据：无连胜（全是Draw/Lose）
    SELECT 3, '2025-01-01', 'Draw' UNION ALL
    SELECT 3, '2025-01-02', 'Lose'
)
```
```sql
WITH Matches (player_id, match_day, result) AS (
    -- 选手1的比赛数据：3连胜（Win）+ 中断（Draw）+ 2连胜（Win）
    SELECT 1, '2025-01-01', 'Win' UNION ALL
    SELECT 1, '2025-01-02', 'Win' UNION ALL
    SELECT 1, '2025-01-03', 'Win' UNION ALL
    SELECT 1, '2025-01-04', 'Draw' UNION ALL
    SELECT 1, '2025-01-05', 'Win' UNION ALL
    SELECT 1, '2025-01-06', 'Win' UNION ALL
    -- 选手2的比赛数据：2连胜（Win）+ 中断（Lose）+ 4连胜（Win）
    SELECT 2, '2025-01-01', 'Win' UNION ALL
    SELECT 2, '2025-01-02', 'Win' UNION ALL
    SELECT 2, '2025-01-03', 'Lose' UNION ALL
    SELECT 2, '2025-01-04', 'Win' UNION ALL
    SELECT 2, '2025-01-05', 'Win' UNION ALL
    SELECT 2, '2025-01-06', 'Win' UNION ALL
    SELECT 2, '2025-01-07', 'Win' UNION ALL
    -- 选手3的比赛数据：无连胜（全是Draw/Lose）
    SELECT 3, '2025-01-01', 'Draw' UNION ALL
    SELECT 3, '2025-01-02', 'Lose'
)
```
